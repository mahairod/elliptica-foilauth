/*
 * Copyright (C) 2019-2023 Slava Monich <slava@monich.com>
 * Copyright (C) 2019-2022 Jolla Ltd.
 *
 * You may use this file under the terms of the BSD license as follows:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer
 *     in the documentation and/or other materials provided with the
 *     distribution.
 *  3. Neither the names of the copyright holders nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING
 * IN ANY WAY OUT OF THE USE OR INABILITY TO USE THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * any official policies, either expressed or implied.
 */

#include "FoilAuthToken.h"
#include "FoilAuth.h"

#include "HarbourBase32.h"
#include "HarbourDebug.h"

#include <QCoreApplication>

#include <glib.h>

#define ARRAY_AND_SIZE(a) a, sizeof(a)

/*==========================================================================*
 * basic
 *==========================================================================*/

static
void
test_basic(
    void)
{
    static const uchar secret[] = {
        0xA9, 0xD0, 0x85, 0x4E, 0xA9, 0x17, 0x98, 0x47, 0x16, 0x69
    };
    const QByteArray secretData((char*)secret, sizeof(secret));
    const QByteArray secretData2((char*)secret, sizeof(secret)/2);

    FoilAuthToken token1(FoilAuthTypes::AuthTypeTOTP, secretData, "Label",
        "Issuer", 1, FoilAuthTypes::DEFAULT_COUNTER, 10);
    FoilAuthToken token2(token1);
    FoilAuthToken token3;

    g_assert(token1.isValid());
    g_assert(token1 == token2);
    g_assert(token1 != token3);
    token3 = token2;
    g_assert(token1 == token3);
    g_assert(token1.secret() == secretData);
    g_assert(token1.secretBase32() == QString("vhiiktvjc6meoftj"));

    g_assert(token3.withType((FoilAuthTypes::AuthType)-1) == token3);
    g_assert(token3.withDigits(0) == token3);
    g_assert(token3.withDigits(FoilAuthTypes::MAX_DIGITS + 1) == token3);
    g_assert(token3.withAlgorithm((FoilAuthTypes::DigestAlgorithm)-1) == token3);
    g_assert(token3.withType(token3.type()) == token3);
    g_assert(token3.withAlgorithm(token3.algorithm()) == token3);
    g_assert(token3.withDigits(token3.digits()) == token3);
    g_assert(token3.withCounter(token3.counter()) == token3);
    g_assert(token3.withSecret(token3.secret()) == token3);
    g_assert(token3.withLabel(token3.label()) == token3);
    g_assert(token3.withIssuer(token3.issuer()) == token3);
    g_assert(token3.withTimeshift(token3.timeshift()) == token3);

    token2 = token3.withType(FoilAuthTypes::AuthTypeHOTP);
    g_assert(token2 != token3);
    g_assert_cmpint(token2.type(), == ,FoilAuthTypes::AuthTypeHOTP);

    token2 = token3.withAlgorithm(FoilAuthTypes::DigestAlgorithmSHA512);
    g_assert(token2 != token3);
    g_assert_cmpint(token2.algorithm(),==,FoilAuthTypes::DigestAlgorithmSHA512);

    token2 = token3.withSecret(secretData2);
    g_assert(token2 != token3);
    g_assert(token2.secret() == secretData2);
    g_assert(token2.secretBase32() == QString("vhiiktvj"));

    token2 = token3.withLabel("Label2");
    g_assert(token2 != token3);
    g_assert(token2.label() == QString("Label2"));

    token2 = token3.withIssuer("Issuer2");
    g_assert(token2 != token3);
    g_assert(token2.issuer() == QString("Issuer2"));

    token2 = token3.withCounter(12345);
    g_assert(token2 != token3);
    g_assert_cmpint(token2.counter(), == ,12345);

    token2 = token3.withDigits(token3.digits() + 1);
    g_assert(token2 != token3);
    g_assert_cmpint(token2.digits(), == ,token3.digits() + 1);

    token2 = token3.withTimeshift(token3.timeshift() + 1);
    g_assert(token2 != token3);
    g_assert_cmpint(token2.timeshift(), == ,token3.timeshift() + 1);
}

/*==========================================================================*
 * validDigits
 *==========================================================================*/

static
void
test_validDigits(
    void)
{
    g_assert_cmpint(FoilAuthToken::validDigits(FoilAuthTypes::MIN_DIGITS), == ,FoilAuthTypes::MIN_DIGITS);
    g_assert_cmpint(FoilAuthToken::validDigits(FoilAuthTypes::MIN_DIGITS - 1), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(FoilAuthToken::validDigits(FoilAuthTypes::MAX_DIGITS), == ,FoilAuthTypes::MAX_DIGITS);
    g_assert_cmpint(FoilAuthToken::validDigits(FoilAuthTypes::MAX_DIGITS + 1), == ,FoilAuthTypes::DEFAULT_DIGITS);
}

/*==========================================================================*
 * invalid
 *==========================================================================*/

static
void
test_invalid(
    void)
{
    FoilAuthToken invalid;

    g_assert(!invalid.isValid());
    g_assert_cmpint(invalid.type(), == ,FoilAuthTypes::DEFAULT_AUTH_TYPE);
    g_assert_cmpint(invalid.algorithm(), == ,FoilAuthTypes::DEFAULT_ALGORITHM);
    g_assert(invalid.label().isEmpty());
    g_assert(invalid.issuer().isEmpty());
    g_assert(invalid.secret().isEmpty());
    g_assert(invalid.secretBase32().isEmpty());
    g_assert_cmpint(invalid.timeshift(), == ,0);
    g_assert_cmpint(invalid.counter(), == ,0);
    g_assert_cmpint(invalid.digits(), == ,0);
    g_assert(invalid.passwordString(123456789).isEmpty());

    g_assert(invalid.withType(FoilAuthTypes::DEFAULT_AUTH_TYPE) == invalid);
    g_assert(invalid.withAlgorithm(FoilAuthTypes::DEFAULT_ALGORITHM) == invalid);
    g_assert(invalid.withLabel(QString("foo")) == invalid);
    g_assert(invalid.withIssuer(QString("bar")) == invalid);
    g_assert(invalid.withSecret(QByteArray()) == invalid);
    g_assert(invalid.withTimeshift(1) == invalid);
    g_assert(invalid.withCounter(1) == invalid);
    g_assert(invalid.withDigits(FoilAuthTypes::DEFAULT_DIGITS) == invalid);
}

/*==========================================================================*
 * password
 *==========================================================================*/

static
void
test_password(
    void)
{
    QByteArray data = HarbourBase32::fromBase32("VHIIKTVJC6MEOFTJ");
    FoilAuthToken token(FoilAuthTypes::AuthTypeTOTP, data, "Label", "Issuer");
    g_assert(token.passwordString(1548529350) == QString("038068"));
}

/*==========================================================================*
 * fromUri
 *==========================================================================*/

static
void
test_fromUri(
    void)
{
    static const uchar bytes[] = {
        0xA9, 0xD0, 0x85, 0x4E, 0xA9, 0x17, 0x98, 0x47, 0x16, 0x69
    };

    g_assert(!FoilAuthToken::fromUri("otpauth://totp/").isValid());
    g_assert(!FoilAuthToken::fromUri("otpauth://totp/.....").isValid());
    g_assert(!FoilAuthToken::fromUri("otpauth://totp/Test Secret?issuer=Test Issuer").isValid());
    g_assert(!FoilAuthToken::fromUri("auth://totp/Test Secret?issuer=Test Issuer").isValid());

    FoilAuthToken token;

    token = FoilAuthToken::fromUri("otpauth://totp/Test Secret?secret=VHIIKTVJC6MEOFTJ&issuer=Test Issuer&foo=bar");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)));
    g_assert(token.secretBase32() == QString("vhiiktvjc6meoftj"));
    g_assert(token.label() == QString("Test Secret"));
    g_assert(token.issuer() == QString("Test Issuer"));
    g_assert_cmpint(token.digits(), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(token.counter(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DEFAULT_ALGORITHM);


    token = FoilAuthToken::fromUri("otpauth://totp/?secret=VHIIKTVJ&digits=2&algorithm=foo");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)/2));
    g_assert(token.secretBase32() == QString("vhiiktvj"));
    g_assert(token.label().isEmpty());
    g_assert(token.issuer().isEmpty());
    g_assert_cmpint(token.digits(), == ,2);
    g_assert_cmpint(token.counter(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DEFAULT_ALGORITHM);

    token = FoilAuthToken::fromUri("otpauth://totp/?secret=VHIIKTVJ&digits=x&algorithm=SHA1");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)/2));
    g_assert(token.secretBase32() == QString("vhiiktvj"));
    g_assert(token.label().isEmpty());
    g_assert(token.issuer().isEmpty());
    g_assert_cmpint(token.digits(), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(token.counter(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA1);

    token = FoilAuthToken::fromUri("otpauth://totp/?secret=VHIIKTVJ&digits=x&algorithm=SHA256");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)/2));
    g_assert(token.secretBase32() == QString("vhiiktvj"));
    g_assert(token.label().isEmpty());
    g_assert(token.issuer().isEmpty());
    g_assert_cmpint(token.digits(), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(token.counter(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA256);

    token = FoilAuthToken::fromUri("otpauth://totp/?secret=VHIIKTVJ&digits=x&algorithm=SHA512");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)/2));
    g_assert(token.secretBase32() == QString("vhiiktvj"));
    g_assert(token.label().isEmpty());
    g_assert(token.issuer().isEmpty());
    g_assert_cmpint(token.digits(), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(token.counter(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA512);

    token = FoilAuthToken::fromUri("otpauth://hotp/HOTP%20test?secret=vhiiktvjc6meoftj&digits=6&counter=3");
    g_assert(token.isValid());
    g_assert(token.secret() == QByteArray((char*)bytes, sizeof(bytes)));
    g_assert(token.secretBase32() == QString("vhiiktvjc6meoftj"));
    g_assert(token.label() == QString("HOTP test"));
    g_assert(token.issuer().isEmpty());
    g_assert_cmpint(token.digits(), == ,FoilAuthTypes::DEFAULT_DIGITS);
    g_assert_cmpint(token.counter(), == ,3);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DEFAULT_ALGORITHM);
}

/*==========================================================================*
 * toUri
 *==========================================================================*/

static
void
test_toUri(
    void)
{
    static const uchar bytes[] = {
        0xA9, 0xD0, 0x85, 0x4E, 0xA9, 0x17, 0x98, 0x47, 0x16, 0x69
    };

    FoilAuthToken token;
    g_assert(token.toUri().isEmpty());

    token = FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)bytes, sizeof(bytes)), QString(), QString());
    g_assert(token.toUri() == QString("otpauth://totp/?secret=vhiiktvjc6meoftj&digits=6"));

    token = FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)bytes, sizeof(bytes)),
        "Test Secret", "Test Issuer", 5);

    QString uri(token.toUri());
    g_assert(uri == QString("otpauth://totp/Test%20Secret?secret=vhiiktvjc6meoftj&issuer=Test%20Issuer&digits=5"));

    FoilAuthToken token2 = FoilAuthToken::fromUri(uri);
    g_assert(token2.isValid());
    g_assert(token2 == token);

    // Algorithm
    uri = FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)bytes, sizeof(bytes)), "Test",
        QString(), 6, FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA1).toUri();
    g_assert(uri == QString("otpauth://totp/Test?secret=vhiiktvjc6meoftj&digits=6"));

    uri = FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)bytes, sizeof(bytes)), "Test",
        QString(), 6, FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA256).toUri();
    g_assert(uri == QString("otpauth://totp/Test?secret=vhiiktvjc6meoftj&digits=6&algorithm=SHA256"));

    uri = FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)bytes, sizeof(bytes)), "Test",
        QString(), 6, FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA512).toUri();
    g_assert(uri == QString("otpauth://totp/Test?secret=vhiiktvjc6meoftj&digits=6&algorithm=SHA512"));
}

/*==========================================================================*
 * toVariantMap
 *==========================================================================*/

static
void
test_toVariantMap(
    void)
{
    // Invalid token
    QVariantMap map = FoilAuthToken().toVariantMap();
    g_assert(map.count() == 1);
    g_assert(map.contains(FoilAuthToken::KEY_VALID));
    g_assert(!map.value(FoilAuthToken::KEY_VALID).toBool());

    // Valid token
    FoilAuthToken token = FoilAuthToken::fromUri("otpauth://totp/Test?secret=vhiiktvjc6meoftj&issuer=Issuer&digits=5");
    g_assert(token.isValid());
    map = token.toVariantMap();

    g_assert_cmpint(map.count(), == ,9);
    g_assert(map.value(FoilAuthToken::KEY_VALID).toBool());
    g_assert_cmpint(map.value(FoilAuthToken::KEY_TYPE).toInt(), == ,FoilAuthTypes::AuthTypeTOTP);
    g_assert(map.value(FoilAuthToken::KEY_LABEL).toString() == QString("Test"));
    g_assert(map.value(FoilAuthToken::KEY_SECRET).toString() == QString("vhiiktvjc6meoftj"));
    g_assert(map.value(FoilAuthToken::KEY_ISSUER).toString() == QString("Issuer"));
    g_assert_cmpint(map.value(FoilAuthToken::KEY_DIGITS).toInt(), == ,5);
    g_assert_cmpint(map.value(FoilAuthToken::KEY_COUNTER).toInt(), == ,FoilAuthTypes::DEFAULT_COUNTER);
    g_assert_cmpint(map.value(FoilAuthToken::KEY_TIMESHIFT).toInt(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(map.value(FoilAuthToken::KEY_ALGORITHM).toInt(), == ,FoilAuthTypes::DEFAULT_ALGORITHM);
}

/*==========================================================================*
 * test_toProtoBuf
 *==========================================================================*/

static
void
test_toProtoBuf(
    void)
{
    static const uchar bytes[] = {
        0x0a, 0x4f, 0x0a, 0x14, 0x85, 0x29, 0xe2, 0x03,
        0x46, 0x3b, 0xa2, 0x66, 0x0f, 0x5a, 0x93, 0x75,
        0x85, 0x53, 0xd5, 0x52, 0x24, 0x25, 0x60, 0x06,
        0x12, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
        0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e,
        0x79, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x40, 0x65,
        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x0f, 0x45, 0x78, 0x61, 0x6d,
        0x70, 0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70,
        0x61, 0x6e, 0x79, 0x20, 0x01, 0x28, 0x01, 0x30,
        0x02,

        0x0a, 0x37, 0x0a, 0x0a, 0x5f, 0x7a, 0x82, 0xa1,
        0x79, 0x58, 0x3c, 0x32, 0x48, 0x0e, 0x12, 0x18,
        0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x65, 0x73,
        0x73, 0x3a, 0x54, 0x68, 0x69, 0x6e, 0x6b, 0x69,
        0x6e, 0x67, 0x54, 0x65, 0x61, 0x70, 0x6f, 0x74,
        0x1a, 0x09, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x72,
        0x65, 0x73, 0x73, 0x20, 0x02, 0x28, 0x02, 0x30,
        0x02,

        0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
        0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
        0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
        0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x20, 0x03, 0x28, 0x01, 0x30, 0x02,

        0x0a, 0x29, 0x0a, 0x14, 0x61, 0xcd, 0x4d, 0xe3,
        0x09, 0x48, 0xfd, 0x6e, 0x71, 0x54, 0xa9, 0x07,
        0xc2, 0xb8, 0x74, 0x6b, 0x78, 0x93, 0xa5, 0xb0,
        0x12, 0x09, 0x48, 0x4f, 0x54, 0x50, 0x20, 0x74,
        0x65, 0x73, 0x74, 0x20, 0x01, 0x28, 0x01, 0x30,
        0x01, 0x38, 0x03,

        0x10, 0x01, /* version = 1 */
        0x18, 0x01, /* batch_size = 1 */
        0x20, 0x00, /* batch_index = 0 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const uchar secret0[] = {
        0x85, 0x29, 0xe2, 0x03, 0x46, 0x3b, 0xa2, 0x66,
        0x0f, 0x5a, 0x93, 0x75, 0x85, 0x53, 0xd5, 0x52,
        0x24, 0x25, 0x60, 0x06
    };

    static const uchar secret1[] = {
        0x5f, 0x7a, 0x82, 0xa1, 0x79, 0x58, 0x3c, 0x32,
        0x48, 0x0e
    };

    static const uchar secret2[] = {
        0x82, 0x6b, 0xb2, 0x37, 0xa9, 0x4a, 0x4e, 0x68,
        0x71, 0xea, 0xdb, 0x3c, 0x4e, 0xff, 0xd8, 0x65,
        0xa8, 0x2e, 0x8f, 0x97
    };
    static const uchar secret3[] = {
        0x61, 0xcd, 0x4d, 0xe3, 0x09, 0x48, 0xfd, 0x6e,
        0x71, 0x54, 0xa9, 0x07, 0xc2, 0xb8, 0x74, 0x6b,
        0x78, 0x93, 0xa5, 0xb0
    };

    QList<FoilAuthToken> tokens;
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret0, sizeof(secret0)),
        "Example Company:test@example.com", "Example Company", 6,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA1));
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret1, sizeof(secret1)),
        "WordPress:ThinkingTeapot", "WordPress", 8,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA256));
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret2, sizeof(secret2)),
        "Google:example@gmail.com", "Google", 6,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA512));
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeHOTP,
        QByteArray((char*)secret3, sizeof(secret3)),
       "HOTP test", "", FoilAuthTypes::DEFAULT_DIGITS, 3));

    const QByteArray protobuf = FoilAuthToken::toProtoBuf(tokens);
    gsize size = protobuf.size();
    const guint random_tail = 10;
    g_assert_cmpuint(size, > ,sizeof(bytes) - random_tail);
    g_assert(!memcmp(protobuf.constData(), bytes, sizeof(bytes) - random_tail));
}

/*==========================================================================*
 * test_toProtoBufs
 *==========================================================================*/

static
void
test_toProtoBufs(
    void)
{
    static const uchar bytes[] = {
        0x0a, 0x4f, 0x0a, 0x14, 0x85, 0x29, 0xe2, 0x03,
        0x46, 0x3b, 0xa2, 0x66, 0x0f, 0x5a, 0x93, 0x75,
        0x85, 0x53, 0xd5, 0x52, 0x24, 0x25, 0x60, 0x06,
        0x12, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
        0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e,
        0x79, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x40, 0x65,
        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x0f, 0x45, 0x78, 0x61, 0x6d,
        0x70, 0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70,
        0x61, 0x6e, 0x79, 0x20, 0x01, 0x28, 0x01, 0x30,
        0x02,

        0x0a, 0x37, 0x0a, 0x0a, 0x5f, 0x7a, 0x82, 0xa1,
        0x79, 0x58, 0x3c, 0x32, 0x48, 0x0e, 0x12, 0x18,
        0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x65, 0x73,
        0x73, 0x3a, 0x54, 0x68, 0x69, 0x6e, 0x6b, 0x69,
        0x6e, 0x67, 0x54, 0x65, 0x61, 0x70, 0x6f, 0x74,
        0x1a, 0x09, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x72,
        0x65, 0x73, 0x73, 0x20, 0x02, 0x28, 0x02, 0x30,
        0x02,

        0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
        0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
        0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
        0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x20, 0x03, 0x28, 0x01, 0x30, 0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x01, /* batch_size = 1 */
        0x20, 0x00, /* batch_index = 0 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const uchar bytes_0_2[] = {
        0x0a, 0x4f, 0x0a, 0x14, 0x85, 0x29, 0xe2, 0x03,
        0x46, 0x3b, 0xa2, 0x66, 0x0f, 0x5a, 0x93, 0x75,
        0x85, 0x53, 0xd5, 0x52, 0x24, 0x25, 0x60, 0x06,
        0x12, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
        0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e,
        0x79, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x40, 0x65,
        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x0f, 0x45, 0x78, 0x61, 0x6d,
        0x70, 0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70,
        0x61, 0x6e, 0x79, 0x20, 0x01, 0x28, 0x01, 0x30,
        0x02,

        0x0a, 0x37, 0x0a, 0x0a, 0x5f, 0x7a, 0x82, 0xa1,
        0x79, 0x58, 0x3c, 0x32, 0x48, 0x0e, 0x12, 0x18,
        0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x65, 0x73,
        0x73, 0x3a, 0x54, 0x68, 0x69, 0x6e, 0x6b, 0x69,
        0x6e, 0x67, 0x54, 0x65, 0x61, 0x70, 0x6f, 0x74,
        0x1a, 0x09, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x72,
        0x65, 0x73, 0x73, 0x20, 0x02, 0x28, 0x02, 0x30,
        0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x02, /* batch_size = 2 */
        0x20, 0x00, /* batch_index = 0 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const uchar bytes_1_2[] = {
        0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
        0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
        0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
        0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x20, 0x03, 0x28, 0x01, 0x30, 0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x02, /* batch_size = 2 */
        0x20, 0x01, /* batch_index = 1 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const GUtilData bytes_2[] = {
        { ARRAY_AND_SIZE(bytes_0_2) },
        { ARRAY_AND_SIZE(bytes_1_2) }
    };

    static const uchar bytes_0_3[] = {
        0x0a, 0x37, 0x0a, 0x0a, 0x5f, 0x7a, 0x82, 0xa1,
        0x79, 0x58, 0x3c, 0x32, 0x48, 0x0e, 0x12, 0x18,
        0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x65, 0x73,
        0x73, 0x3a, 0x54, 0x68, 0x69, 0x6e, 0x6b, 0x69,
        0x6e, 0x67, 0x54, 0x65, 0x61, 0x70, 0x6f, 0x74,
        0x1a, 0x09, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x72,
        0x65, 0x73, 0x73, 0x20, 0x02, 0x28, 0x02, 0x30,
        0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x02, /* batch_size = 2 */
        0x20, 0x00, /* batch_index = 0 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const uchar bytes_1_3[] = {
        0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
        0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
        0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
        0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x20, 0x03, 0x28, 0x01, 0x30, 0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x02, /* batch_size = 2 */
        0x20, 0x01, /* batch_index = 0 */
        0x28,       /* batch_id */
        /* Random batch id, not compared: */
        0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff,
        0xff, 0x01
    };

    static const GUtilData bytes_3[] = {
        { ARRAY_AND_SIZE(bytes_0_3) },
        { ARRAY_AND_SIZE(bytes_1_3) }
    };

    static const uchar secret0[] = {
        0x85, 0x29, 0xe2, 0x03, 0x46, 0x3b, 0xa2, 0x66,
        0x0f, 0x5a, 0x93, 0x75, 0x85, 0x53, 0xd5, 0x52,
        0x24, 0x25, 0x60, 0x06
    };

    static const uchar secret1[] = {
        0x5f, 0x7a, 0x82, 0xa1, 0x79, 0x58, 0x3c, 0x32,
        0x48, 0x0e
    };

    static const uchar secret2[] = {
        0x82, 0x6b, 0xb2, 0x37, 0xa9, 0x4a, 0x4e, 0x68,
        0x71, 0xea, 0xdb, 0x3c, 0x4e, 0xff, 0xd8, 0x65,
        0xa8, 0x2e, 0x8f, 0x97
    };

    // Last 10 bytes (batch id) are not getting compared
    const guint random_tail = 10;

    QList<FoilAuthToken> tokens;
    // No tokens - no protobufs
    g_assert(FoilAuthToken::toProtoBufs(tokens).isEmpty());

    // Build the token list
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret0, sizeof(secret0)),
        "Example Company:test@example.com", "Example Company", 6,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA1));
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret1, sizeof(secret1)),
        "WordPress:ThinkingTeapot", "WordPress", 8,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA256));
    tokens.append(FoilAuthToken(FoilAuthTypes::AuthTypeTOTP,
        QByteArray((char*)secret2, sizeof(secret2)),
        "Google:example@gmail.com", "Google", 6,
        FoilAuthTypes::DEFAULT_COUNTER,
        FoilAuthTypes::DEFAULT_TIMESHIFT,
        FoilAuthTypes::DigestAlgorithmSHA512));

    // One protobuf
    QList<QByteArray> protobufs = FoilAuthToken::toProtoBufs(tokens);
    g_assert_cmpint(protobufs.size(), == ,1);
    QByteArray protobuf(protobufs.at(0));
    g_assert_cmpuint(protobuf.size(), > ,sizeof(bytes) - random_tail);
    g_assert(!memcmp(protobuf.constData(), bytes, sizeof(bytes) - random_tail));

    // Batch of 2 protobufs
    protobufs = FoilAuthToken::toProtoBufs(tokens, 160);
    g_assert_cmpint(protobufs.size(), == ,G_N_ELEMENTS(bytes_2));
    for (uint i = 0; i < G_N_ELEMENTS(bytes_2); i++) {
        const GUtilData* batch = bytes_2 + i;
        const gsize bytes_to_compare = batch->size - random_tail;
        protobuf = protobufs.at(i);
        g_assert_cmpuint(protobuf.size(), > ,bytes_to_compare);
        g_assert(!memcmp(protobuf.constData(), batch->bytes, bytes_to_compare));
    }

    // Another batch of 2 protobufs (one token gets skipped for being too big)
    protobufs = FoilAuthToken::toProtoBufs(tokens, 80);
    g_assert_cmpint(protobufs.size(), == ,G_N_ELEMENTS(bytes_3));
    for (uint i = 0; i < G_N_ELEMENTS(bytes_3); i++) {
        const GUtilData* batch = bytes_3 + i;
        const gsize bytes_to_compare = batch->size - random_tail;
        protobuf = protobufs.at(i);
        g_assert_cmpuint(protobuf.size(), > ,bytes_to_compare);
        g_assert(!memcmp(protobuf.constData(), batch->bytes, bytes_to_compare));
    }

    // Nothing fits into 20 bytes
    g_assert(FoilAuthToken::toProtoBufs(tokens, 20).isEmpty());
}

/*==========================================================================*
 * test_fromProtoBuf
 *==========================================================================*/

static
void
test_fromProtoBuf(
    void)
{
    static const uchar bytes[] = {
        0x0a, 0x4f, 0x0a, 0x14, 0x85, 0x29, 0xe2, 0x03,
        0x46, 0x3b, 0xa2, 0x66, 0x0f, 0x5a, 0x93, 0x75,
        0x85, 0x53, 0xd5, 0x52, 0x24, 0x25, 0x60, 0x06,
        0x12, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
        0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e,
        0x79, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x40, 0x65,
        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x0f, 0x45, 0x78, 0x61, 0x6d,
        0x70, 0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70,
        0x61, 0x6e, 0x79, 0x20, 0x01, 0x28, 0x01, 0x30,
        0x02,

        0x0a, 0x37, 0x0a, 0x0a, 0x5f, 0x7a, 0x82, 0xa1,
        0x79, 0x58, 0x3c, 0x32, 0x48, 0x0e, 0x12, 0x18,
        0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x65, 0x73,
        0x73, 0x3a, 0x54, 0x68, 0x69, 0x6e, 0x6b, 0x69,
        0x6e, 0x67, 0x54, 0x65, 0x61, 0x70, 0x6f, 0x74,
        0x1a, 0x09, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x72,
        0x65, 0x73, 0x73, 0x20, 0x02, 0x28, 0x02, 0x30,
        0x02,

        0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
        0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
        0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
        0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
        0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x20, 0x03, 0x28, 0x01, 0x30, 0x02,

        0x10, 0x01, /* version = 1 */
        0x18, 0x01, /* batch_size = 1 */
        0x20, 0x00, /* batch_index = 0 */
        0x28, 0xe7, 0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff,
        0xff, 0xff, 0x01 /* batch_id */
    };

    static const uchar secret0[] = {
        0x85, 0x29, 0xe2, 0x03, 0x46, 0x3b, 0xa2, 0x66,
        0x0f, 0x5a, 0x93, 0x75, 0x85, 0x53, 0xd5, 0x52,
        0x24, 0x25, 0x60, 0x06
    };

    static const uchar secret1[] = {
        0x5f, 0x7a, 0x82, 0xa1, 0x79, 0x58, 0x3c, 0x32,
        0x48, 0x0e
    };

    static const uchar secret2[] = {
        0x82, 0x6b, 0xb2, 0x37, 0xa9, 0x4a, 0x4e, 0x68,
        0x71, 0xea, 0xdb, 0x3c, 0x4e, 0xff, 0xd8, 0x65,
        0xa8, 0x2e, 0x8f, 0x97
    };

    QByteArray buf((char*)bytes, sizeof(bytes));
    QList<FoilAuthToken> result(FoilAuthToken::fromProtoBuf(buf));
    g_assert_cmpint(result.count(), == ,3);

    FoilAuthToken token = result.at(0);
    g_assert(token.secret() == QByteArray((char*)secret0, sizeof(secret0)));
    g_assert(token.label() == QString("Example Company:test@example.com"));
    g_assert(token.issuer() == QString("Example Company"));
    g_assert_cmpint(token.digits(), == ,6);
    g_assert_cmpint(token.timeshift(), == ,FoilAuthTypes::DEFAULT_TIMESHIFT);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA1);

    token = result.at(1);
    g_assert(token.secret() == QByteArray((char*)secret1, sizeof(secret1)));
    g_assert(token.label() == QString("WordPress:ThinkingTeapot"));
    g_assert(token.issuer() == QString("WordPress"));
    g_assert_cmpint(token.digits(), == ,8);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA256);

    token = result.at(2);
    g_assert(token.secret() == QByteArray((char*)secret2, sizeof(secret2)));
    g_assert(token.label() == QString("Google:example@gmail.com"));
    g_assert(token.issuer() == QString("Google"));
    g_assert_cmpint(token.digits(), == ,6);
    g_assert_cmpint(token.algorithm(), == ,FoilAuthTypes::DigestAlgorithmSHA512);
}

/*==========================================================================*
 * test_fromProtoBufFail
 *==========================================================================*/

static const guint8 fail_data1[] = {
    0x10, 0x01, 0x18, 0x01, 0x20, 0x00, 0x28, 0xe7,
    0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff, 0xff
    /* Truncated message */
};
static const guint8 fail_data2[] = {
    0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff
    /* Broken varint */
};
static const guint8 fail_data3[] = {
    0x15, 0x01, 0x02, 0x03, 0x04
    /* Unsupported tag type */
};
static const guint8 fail_data4[] = {
    0x10, 0x01, 0x18, 0x01, 0x20, 0x00, 0x28, 0xe7,
    0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff, 0xff,
    0x01, 0x0a /* OtpParameters is completely missing */
};
static const guint8 fail_data5[] = {
    0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28, 0x01, 0x30, 0x03
                           /* Invalid OtpType ^^^^ */
};
static const guint8 fail_data6[] = {
    0x10, 0x01, 0x18, 0x01, 0x20, 0x00, 0x28, 0xe7,
    0xac, 0xc0, 0xc6, 0xf9, 0xff, 0xff, 0xff, 0xff,
    0x01, 0x0a, 0x4e, 0x0a, 0x14, 0x85, 0x29, 0xe2,
    0x03, 0x46, 0x3b, 0xa2, 0x66, 0x0f, 0x5a, 0x93,
    0x75, 0x85, 0x53, 0xd5, 0x52, 0x24, 0x25, 0x60,
    0x06, 0x12, 0x20, 0x45, 0x78, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61,
    0x6e, 0x79, 0x3a, 0x74, 0x65, 0x73, 0x74, 0x40,
    0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e,
    0x63, 0x6f, 0x6d, 0x1a, 0x0f, 0x45, 0x78, 0x61,
    0x6d, 0x70, 0x6c, 0x65, 0x20, 0x43, 0x6f, 0x6d,
    0x70, 0x61, 0x6e, 0x79, 0x20, 0x01, 0x28, 0x01,
    0x30 /* OtpType value is missing */
};
static const guint8 fail_data7[] = {
    0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x07, 0x28, 0x01, 0x30, 0x02
    /* Bad Algorithm  ^^^^ */
};
static const guint8 fail_data8[] = {
    0x0a, 0x39, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20  /* Algorithm value is missing */
};
static const guint8 fail_data9[] = {
    0x0a, 0x3e, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28, 0x07, 0x30, 0x02,
                   /* Bad Digits  ^^^^ */
};
static const guint8 fail_data10[] = {
    0x0a, 0x3b, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28 /* Digits value is missing */
};
static const guint8 fail_data11[] = {
    0x0a, 0x3f, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28, 0x07, 0x30, 0x01,
    0x38 /* Counter value missing */
};
static const guint8 fail_data12[] = {
    0x0a, 0x3f, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28, 0x07, 0x30, 0x01,
    0x78 /* Unsupported tag in OtpParameters block */
};
static const guint8 fail_data13[] = {
    0x0a, 0x32, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06 /* Issuer value is truncated */
};
static const guint8 fail_data14[] = {
    0x0a, 0x18, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18  /* Name value is missing */
};
static const guint8 fail_data15[] = {
    0x0a, 0x12, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65 /* Secret value is truncated */
};
static const guint8 fail_data16[] = {
    0x0a, 0x34, 0x12, 0x0d, 0x61, 0x75, 0x74, 0x68,
    0x40, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x63, 0x6f,
    0x6d, 0x1a, 0x1d, 0x4d, 0x79, 0x43, 0x6f, 0x6d,
    0x70, 0x61, 0x6e, 0x79, 0x4e, 0x61, 0x6d, 0x65,
    0x2e, 0x41, 0x62, 0x70, 0x5a, 0x65, 0x72, 0x6f,
    0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65,
    0x20, 0x01, 0x28, 0x01, 0x30, 0x02 /* No Secret */
};
static const guint8 fail_data17[] = {
    0x0a, 0x3f, 0x0a, 0x14, 0x82, 0x6b, 0xb2, 0x37,
    0xa9, 0x4a, 0x4e, 0x68, 0x71, 0xea, 0xdb, 0x3c,
    0x4e, 0xff, 0xd8, 0x65, 0xa8, 0x2e, 0x8f, 0x97,
    0x12, 0x18, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
    0x3a, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x40, 0x67, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63,
    0x6f, 0x6d, 0x1a, 0x06, 0x47, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x20, 0x01, 0x28, 0x07, 0x30, 0x01,
    0xff /* Garbage at the end of OtpParameters block */
};

static const GUtilData fromProtoBufFail_tests[] = {
    { ARRAY_AND_SIZE(fail_data1) },
    { ARRAY_AND_SIZE(fail_data2) },
    { ARRAY_AND_SIZE(fail_data3) },
    { ARRAY_AND_SIZE(fail_data4) },
    { ARRAY_AND_SIZE(fail_data5) },
    { ARRAY_AND_SIZE(fail_data6) },
    { ARRAY_AND_SIZE(fail_data7) },
    { ARRAY_AND_SIZE(fail_data8) },
    { ARRAY_AND_SIZE(fail_data9) },
    { ARRAY_AND_SIZE(fail_data10) },
    { ARRAY_AND_SIZE(fail_data11) },
    { ARRAY_AND_SIZE(fail_data12) },
    { ARRAY_AND_SIZE(fail_data13) },
    { ARRAY_AND_SIZE(fail_data14) },
    { ARRAY_AND_SIZE(fail_data15) },
    { ARRAY_AND_SIZE(fail_data16) },
    { ARRAY_AND_SIZE(fail_data17) }
};

static
void
test_fromProtoBufFail(
    gconstpointer test_data)
{
    const GUtilData* bytes = (const GUtilData*) test_data;
    QByteArray buf((char*)bytes->bytes, bytes->size);
    QList<FoilAuthToken> result(FoilAuthToken::fromProtoBuf(buf));
    g_assert_cmpint(result.count(), == ,0);
}

/*==========================================================================*
 * Common
 *==========================================================================*/

#define TEST_(name) "/FoilAuthToken/" name

int main(int argc, char* argv[])
{
    QCoreApplication app(argc, argv);
    g_test_init(&argc, &argv, NULL);
    g_test_add_func(TEST_("basic"), test_basic);
    g_test_add_func(TEST_("validDigits"), test_validDigits);
    g_test_add_func(TEST_("invalid"), test_invalid);
    g_test_add_func(TEST_("password"), test_password);
    g_test_add_func(TEST_("fromUri"), test_fromUri);
    g_test_add_func(TEST_("toUri"), test_toUri);
    g_test_add_func(TEST_("toVariantMap"), test_toVariantMap);
    g_test_add_func(TEST_("toProtoBuf"), test_toProtoBuf);
    g_test_add_func(TEST_("toProtoBufs"), test_toProtoBufs);
    g_test_add_func(TEST_("fromProtoBuf"), test_fromProtoBuf);
    for (uint i = 0; i < G_N_ELEMENTS(fromProtoBufFail_tests); i++) {
        char* path = g_strdup_printf(TEST_("fromProtoBufFail/%u"), i+1);
        g_test_add_data_func(path, fromProtoBufFail_tests + i,
            test_fromProtoBufFail);
        g_free(path);
    }
    return g_test_run();
}

/*
 * Local Variables:
 * mode: C++
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 */
